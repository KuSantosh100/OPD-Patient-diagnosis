# -*- coding: utf-8 -*-
"""OPD_Patients.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LTle4pw0WwTnE32EKkIKEVM298wqRRsy

# Patient Data Analytics

## Importing Libraries
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.metrics import classification_report, accuracy_score
from imblearn.over_sampling import SMOTE
import joblib

"""## Data Loading and Initial Inspection"""

# Load the dataset
df = pd.read_csv("/content/OPMD-PATIENTS.csv")


df.info()
print(df.head())

"""## Data Preprocessing and Cleaning"""

# Cleaning and Standardizing the 'DIAGNOSIS' Column
print("\nCleaning 'DIAGNOSIS' column...")
def clean_diagnosis(diagnosis_str):
    diagnosis_str = str(diagnosis_str).lower().strip()
    if 'oral submucous fibrosis' in diagnosis_str or 'osmf' in diagnosis_str or 'submucous fibrosis' in diagnosis_str or 'submucoous fibrosis' in diagnosis_str or 'submuous fibrosis' in diagnosis_str or 'sub fibrosis' in diagnosis_str or 'sub mucous fibrosis' in diagnosis_str or 'submucousfibrosis' in diagnosis_str or 'submucous fibrosi' in diagnosis_str or 'submucous firbosi' in diagnosis_str or 'submucous fibrrosis' in diagnosis_str or 'submucous fibrsosis' in diagnosis_str or 'submucous fiibrosis' in diagnosis_str or 'oal submucous fibrosis' in diagnosis_str or 'oralsubmucous fibrosis' in diagnosis_str:
        return 'oral submucous fibrosis'
    elif 'oral lichen planus' in diagnosis_str or 'lichen planus' in diagnosis_str or 'erosive lichen planus' in diagnosis_str or 'pigmented lichen planus' in diagnosis_str or 'reticular lichen planus' in diagnosis_str or 'oral lichen planua' in diagnosis_str or 'oral lichen plaanus' in diagnosis_str or 'oral liichen planus' in diagnosis_str:
        return 'oral lichen planus'
    elif 'leukoplakia' in diagnosis_str or 'leukkoplakia' in diagnosis_str or 'leukoplkia' in diagnosis_str:
        return 'leukoplakia'
    elif 'erythroplakia' in diagnosis_str or 'eruthroplakia' in diagnosis_str:
        return 'erythroplakia'
    elif 'frictional keratosis' in diagnosis_str:
        return 'frictional keratosis'
    elif 'tobacco pouch keratosis' in diagnosis_str:
        return 'tobacco pouch keratosis'
    elif 'smoker' in diagnosis_str and 'palate' in diagnosis_str:
        return 'smoker\'s palate'
    elif 'erythroleukoplakia' in diagnosis_str:
        return 'erythroleukoplakia'
    else:
        return 'other'

df['DIAGNOSIS'] = df['DIAGNOSIS'].apply(clean_diagnosis)
print("Unique DIAGNOSIS values after cleaning:")
print(df['DIAGNOSIS'].unique())

# Standardizing 'SOCIOECONOMIC STATUS' Column
print("\nStandardizing 'SOCIOECONOMIC STATUS' column...")
def standardize_socioeconomic_status(status_str):
    """
    Standardize socioeconomic status to four specific categories:
    - Upper Class
    - Lower Class
    - Upper Middle Class
    - Lower Middle Class
    """
    status_str = str(status_str).lower().strip()
    if 'upper class' in status_str:
        return 'Upper Class'
    elif 'lower class' in status_str:
        return 'Lower Class'
    elif 'upper middle class' in status_str:
        return 'Upper Middle Class'
    elif 'lower middle class' in status_str:
        return 'Lower Middle Class'
    else:
        return 'Lower Middle Class'

df['SOCIOECONOMIC STATUS'] = df['SOCIOECONOMIC STATUS'].apply(standardize_socioeconomic_status)
print("Unique SOCIOECONOMIC STATUS values after standardization:")
print(df['SOCIOECONOMIC STATUS'].unique())
print("SOCIOECONOMIC STATUS value counts:")
print(df['SOCIOECONOMIC STATUS'].value_counts())

# Standardizing 'SEX' Column
print("\nStandardizing 'SEX' column...")
def standardize_sex(sex_str):
    """
    Standardize sex to only M and F
    """
    sex_str = str(sex_str).upper().strip()
    if sex_str in ['M', 'MALE']:
        return 'M'
    elif sex_str in ['F', 'FEMALE']:
        return 'F'
    else:
        return 'M'

df['SEX'] = df['SEX'].apply(standardize_sex)
print("Unique SEX values after standardization:")
print(df['SEX'].unique())

# Handling Missing Values & Fill missing 'AGE' with median & Fill missing 'SEX' with mode
print("\nHandling missing values...")
df['AGE'] = df['AGE'].fillna(df['AGE'].median())
df['SEX'] = df['SEX'].fillna(df['SEX'].mode()[0])
print(df.isnull().sum())

# Encoding Categorical Features
# Strip whitespace from column names before encoding to avoid issues
df.columns = df.columns.str.strip()

# Perform encoding on specified categorical columns
df = pd.get_dummies(df, columns=['SEX', 'SOCIOECONOMIC STATUS', 'HABBITS', 'DURATION'])
print("DataFrame head after encoding:")
print(df.head())

"""## Feature Selection and Engineering"""

# Drop identifier columns as they are not useful for prediction
print("Dropping identifier columns ('SL. NO.', 'PATIENT'S NAME')...")
df = df.drop(['SL. NO.', 'PATIENT\'S NAME'], axis=1)
print("DataFrame head after feature selection:")
print(df.head())

# Separate features (X) and target (y)
X = df.drop('DIAGNOSIS', axis=1)
y = df['DIAGNOSIS']

print("Final feature columns:")
print(X.columns.tolist())

"""## Model Development and Comparison"""

# Apply SMOTE to handle class imbalance
print("Applying SMOTE for class imbalance...")
smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X, y)
print("Class distribution after SMOTE:")
print(y_resampled.value_counts())

# Split data into training and testing sets
print("Splitting data into training and testing sets...")
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.2, random_state=42)

# 4.1. Random Forest Classifier
print("\n--- Training Random Forest Classifier ---")
rf_model = RandomForestClassifier(random_state=42)
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)
print("Random Forest Accuracy:", accuracy_score(y_test, y_pred_rf))
print("Random Forest Classification Report:\n", classification_report(y_test, y_pred_rf))

# 4.2. Logistic Regression
print("\n--- Training Logistic Regression ---")
lr_model = LogisticRegression(random_state=42, max_iter=1000) # Increased max_iter for convergence
lr_model.fit(X_train, y_train)
y_pred_lr = lr_model.predict(X_test)
print("Logistic Regression Accuracy:", accuracy_score(y_test, y_pred_lr))
print("Logistic Regression Classification Report:\n", classification_report(y_test, y_pred_lr))

# 4.3. Support Vector Machine (SVC)
print("\n--- Training Support Vector Machine (SVC) ---")
svc_model = SVC(random_state=42)
svc_model.fit(X_train, y_train)
y_pred_svc = svc_model.predict(X_test)
print("SVC Accuracy:", accuracy_score(y_test, y_pred_svc))
print("SVC Classification Report:\n", classification_report(y_test, y_pred_svc))

"""## Feature Importance Analysis (from Random Forest)"""

feature_importances = pd.Series(rf_model.feature_importances_, index=X.columns).sort_values(ascending=False)
print("Feature Importances (from Random Forest):\n", feature_importances)

"""## Save Model and Feature Information"""

# Save the best performing model (Random Forest) and feature columns
joblib.dump(rf_model, "random_forest_model.pkl")
joblib.dump(X_train.columns.tolist(), "feature_columns.pkl")
print("Model and feature columns saved successfully!")